# 23-React1 서동근 


## 04.06(6주차)
### 🎣 훅이란
클래스형 컴포넌트에서는 생성자에서 STATE를 정의하고 setState()함수를 통해 state를 없데이트 한다

예전에 사용하던 함수형 컴포넌트는 별도로 state를 정의하거나, 컴포넌트의 생명주기에 맞춰서 어떤 코드가 실행되도록 할 수어 없었다

함수형 컴포터넌트에서도 state나 생명주기 함수의 기능을 사용하게 해주기 위해 추가된 기능이 바로 hook이다

함수형 컴포넌트도 혹은 사용하여 클래스형 컴포넌트의 기능을 모두 동일하게 구현할 수 있게 되었다

### userState
useState는 함수형 컴포넌트에서 state를 사용하기 위한 Hook이다

userEffect
userState와 함꼐 가장 많이 사용하는 Hook이다
이 함수는 사이드 이펙트를 수행하기 위한것이다
영어로 side effect는 부장용을 의미한다. '개발자가 의도하지 않는 코드가 실행되면서 버그가 발생하는 것'을 말한다

하지만 리액트에서는 효과 혹은 영향을 뜻하는 effect의 의미에 가깝다

예를 들면 서버에서 데이터를 받아오거나 수동으로 DOM을 변경하는 등의 작업을 의미한다

이작업을 이펙트라고 부르는 이유는 이 작업들이 다른 컴포넌트에 영향을 미칠 수 있으며, 렌더링 중에는 작업이 완료될 수 없이 때문이다.렌더링 이후 실행되어야하는 작업들이다.

클래스 컴포넌트의 생명주기 함수와 같은 기능을 하나로 통합하는 기능을 제공한다.

저자는 useEffect가 side effect가 아니라 effect에 가깝다고 설명하고 있지만, 이것은 부작용의 의미를 잘못해서 생긴 오해이다.

### useMemo
userMemo() 혹은 Memoizde value를 리턴하는 훅입니다
이전 계산값을 가지고 있기 때문에 연산량이 놓은 작업의 반복을 피할 수 있습니다.
히 훅은 렌더링이 일어나는 동안 실행됩니다
따라서 렌더링이 일어나는 동안 실행되서는 안될 작업을 넣으면 안된다.

예시로 useEffect 사이트 이팩트 같은 것이다.

만약 배열을 넣게 되면 컴포넌트 마운트 시에만 함수가 실행된다.

### userCallback
userCallback() 혹은 userMemo()와 유사한 역할을 한다
차이점은 값이 아닌 함수를 반환한다는 점이다
의존성 배열을 파라미터로 받는 것은 useMemo와 동일하다
파라미터로 받은 함수를 콜백이라고 부른다
useMemo와 마찬가지로 의존성 배열 중 하나라도 변경되면 콜백 함수를 반환한다.

userRef
userRef()혹은 레퍼런스를 사용하기 위한 훅이다
레퍼런스란 특정 컴포넌트에 접근할 수 있는 객체를 의미한다
userRef() 훅은 바로 이 레퍼런스 객체를 반환한다
레퍼런스 객체에는 current라는 속성이 있는데, 이것은 현재 참조하고 있는 엘리먼트를 의미한다
컴포넌트가 마운트 해제 전까지는 계속 유ㅣ된다는 의미

### 훅의 규칙
무조건 최상위 컴포넌트 레벨에서만 호출해야만 한다는 것.

따라서 반복문, 조건문, 중첩 함수들 안에서 훅을 호출하면 안된다
이 규칙에 따라 훅은 컴포넌트가 렌더링 될 떄마다 같은 순서로 호출되어야 한다

일반 자바스크립트 함수에서훅을 호출하면 안된다
훅은 리엑트 함수 컴포넌트 혹은 직접 만든 커스텀 훅에서만 호출할 수 있다.


## 04.06(6주차)
### 🎣 컴포넌트 추출
* 복잡한 컴포넌트를 쪼개서 여러 개의 컴포넌트로 나눌 수도 있다
* 큰 컴포넌트에서 일부를 추출해서 새로운 컴포넌트를 만드는 것이다.
* (실무에서는 처음부터 1개의 컴포넌트에 하나의 기능만 사용하도록 설계하는 것이 좋다)

### 👨🏻‍💻컴포넌트 코드 활용
아래와 같은 코드가 추가될 때 가독성이 떨어진다 따라서 배열 변수로 따로 뺴놓고 활용해보자
```js
function CommentList(props) {
    return(
        <div>
            <Comment name={"신동욱"} comment={"안녕하세요. 신동욱입니다."} />
            <Comment name={"신동욱1"} comment={"안녕하세요. 신동욱1입니다."} />
            <Comment name={"신동욱2"} comment={"안녕하세요. 신동욱2입니다."} />
        </div>
    )
}
```

```js
const comments = [
    { name: "신동욱", comment: "안녕하세요, 신동욱입니다.",},
    { name: "신동욱1", comment: "안녕하세요, 신동욱1입니다",},
    { name: "신동욱2", comment: "안녕하세요, 신동욱2입니다",},
];

function CommentList(props) {
    return (
        <div>
            {comments.map((comment) => {
              return (
                <Comment name={comment.name} comment={comment.comment} />
              );
            })}
        </div>
    );
}
```

## 6장 state와 생명주기
* state, 생명주기 모두 클래스 컴포넌트형태에서 사용하는 용어들이다.

### state란?
* state란? 리액트 컴포넌트의 상태를 의미한다.
* 상태 의미는 정상, 비정상이 아닌 컴포넌트의 데이터를 의미.
* 컴포넌트의 변경가능한 데이터를 의미한다.
* State가 변하면 다시 렌더링이 되어 렌더링과 관련된 값만 state에 포함시켜야 한다.

### state의 특징
* 리엑트 만의 특별한 형태가 아닌 단지 자바스크립트 객체일 뿐이다.

<img src="../23-react1/image/state1.png" width="450px" height="300px" title="30%" alt="스테이트 설명"></img><br/>

<img src="../23-react1/image/bread-example.png" width="450px" height="300px" title="30%" alt="(엘리먼트, 컴포넌트, 인스턴스)그림 설명"></img><br/>

---
## 03.30(5주차)
### 🧐 엘리먼트
* 리액트 엘리먼트는 자바스크립트 객체의 형태로 존재한다. <br>
* 컴포넌트(Button 등), 속성(color 등) 및 내부의 모든 children을 포함하는 일반 JS객체이다.<br>
* 이 객체는 마음대로 변경할 수 없는 불변성을 갖고 있다

### 👀 엘리먼트의 특징
* 가장 큰 특징은 불변성이다
* 즉 한 번 생성된 엘리먼트나 그 안에 있는 속성을 바꿀 수 없다.

#### 😗 만일 내용이 바뀌었다면??
* 컴포넌트를 통해 새로운 엘리먼트를 생성해준다.
* 그 후 이전 엘리먼트와 교체를 하는 방벙으로 내용을 바꿔야 한다
* 이렇게 교체하는 작업을하기위해 Virtual DOM의 개념도 이다.
  
### 👀 엘리먼트 렌더링하기
  아래 코드는 id값이 root 태그로 단순한 코드이지만 리액트의 매우 중요한 필수 코드이다
  이 div태그안 리액트 엘리먼트가 렌더링 되며, 이것을 Root DOM node라고 합니다.


  ```js
    <dib id="root"> </div>
  ```

### 컴포넌트 구조란?
* 컴포넌트 구조는 작은 컴포넌트가 모여 큰 컴포넌트를 구성하고, 다시 이런 컴포넌트들이 모여서 전체 페이지를 구성한다는 것을 의미.
* 컴포넌트 재사용이 가능하여 전체 코드양을 줄이고 개발시간, 유지보수 비용 또한 절약된다
* 컴포넌트는 자바스크립트 함수와 입력과 출력이 있다는 면에서 유사하다
* 다만 입출력은 입력은 Props, 출력은 이랙트 엘리먼트의 형태로 출력된다
* 엘리먼트를 필요한 만큼 만들어 사용한다는 면에서는 객체 지향의 개념과 비슷하다.

### Props의 개념
* props는 property(속성, 특성)의 준말이다
* 이 props가 바로 컴포넌트의 속성이다
* 컴포넌트의 어떠한 속성, props를 넣느냐의 따라서 속성이 다른 엘리먼트가 출력된다.
* props는 컴포넌트에 전달 할 다양한 정보를 담고 있는 자바스크립트 객체이다

#### props의 특징
* 읽기 전용이므로 변경이 불가하다
* 속성이 다른 엘리먼트를 생성하려면 새로운 props를 컴포넌트에 전달하면 된다.

Pure 함수 vs, Impure 함수
* 인수로 받은 정보가 함수 내부에서 변하지 않다면 Pure, 변한다면 Impure 이다.
  
중요!
* 컴포넌트를 다 분리해야 파일과 컴포넌트 이름을 일치시킬 수 있다
* 다시 말 해 1개의 클래스파일(컴포넌트 생성)에 두개의 컴포넌트가 정의되어 있으면 혼란을 야기한다.


### 컴포넌트 합성
* 컴포넌트 여러개를 합쳐 하나의 컴포넌트로 만들 수 있다
* 복잡한 화면을 여러 개의 컴포넌트로 나누어 구현할 수 있다
* 개념을 보여줄 목적인 예시를 들어본다 컴포넌트 A를 B에서 3개 사용하여 최종적으로 B만 렌더링하는 예시 -> (a), b(a(1), a(2), a(3))   reder.b

----

## 03.23(4주차)
#### 🔨 React 프로젝트 재생성
(프로젝트 명이 겹치는 상황이 발생하여 react 프로젝트를 다시 만들어봤다.) <br> <br>
1. 프로젝트 삭제 (이때 .git 파일은 꼭 삭제해 준다)
2. visual stuido code -> open folder
3. react 프로젝트 생성
```bash
npx create-react-app 23-react1(프로젝트 명)
```
4. 이후 visual studio code -> source Control -> git repository 만들기(public 추천)

    (여기까지 프로젝트 생성 완료 이후 commit 도 진행해본다)<br>

5. README.MD 수정 -> commit -> push
---
### 👯‍♂️ GIT CLONE
1. 깃 허브 -> 복사 당할 레파지토리 -> [code] -> 주소 확인 후 복사(https)
2. visual studio code -> 복사 받을 폴더 생성 후 열기 -> 터미널 접속
3. git clone [1번에서 복사한 레파지토리 주소]

---
### 🧐 JSX란?
아래의 희한한 태그 문법은 문자열도, HTML도 아니다.<br>
이를 <i>JSX라 하며 JavaScript를 확장한 문법입니다</i>
```JS
const element = <h1>Hello, world!</h1>;
```

#### JSX의 장점
* 코드가 간결해지므로 가독성이 향상된다.

* Injection Attack이라 불리는 해킹 방법을 방어하므로 보에 강하다.
* 모든 자바스크립트 문법을 지원한다.
* 자바 스크립트 문법에 XML과 HTML을 섞어서 사용한다. (XML은 HTML을 확장한 것.) 쉽게 말 해 내가 <태그> 를 정의해서 사용할 수 있다.

### 📦JSX에 표현식 포함하기
아래 예시에서는 name이라는 변수를 선언한 후 중괄호로 감싸 JSX 안에 사용한다.
```JS
const name = 'Josh Perez';
const element = <h1>Hello, {name}</h1>;
```

### 🐧 JSX는 객체를 표현합니다.
Babel은 JSX를 React.createElement() 호출로 컴파일한다.
<br> 아래는 Babel은(바벨)의 역할의 예제이다.
다음 두 예시는 동일하다.
```JS
const element = (
  <h1 className="greeting">
    Hello, world!
  </h1>
);

const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world!'
);
```
--

### 👨🏻‍💻 JSX 실습
JS로 파일로 생성하기 보다는 JSX 명칭 그대로 지정해준다.
```jsx
import React from "react"


// 컴포넌트를 작성하는 곳(파일 명과 일치하게 입력).
function Book(props){
    return (
        <div>
            <h1>{`이 책의 이름은 ${props.name}입니다.`}</h1>
            <h2>{`이 책은 총 ${props.name}페이지로 이루어져 있습니다.`}</h2>
        </div>
    )
}


// 외부에서 사용할 수 있게 설정하는 코드
export default Book
```
---
## 03.16(3주차)
### 🧐 리엑트란?
 사용자 인터페이스를 만들기 위한 자바스크립트의 라이브러리이다
### ☝🏻 리액트의 장점 - 1.빠른 업데이트와 랜더링 속도
1. 빠른 업데이트와 랜더링 속도
2. 동기식 = 모든 페이지를 랜더링, 비동기식 = 변할 부분만 랜더링 됨 ex) 댓글, 페이스 북 게시글
3. DOM은 동기식 Virtual DOM은 비동기식 방법으로 렌더링을 한다
4. 더 설명하자면 DOM은 html 모든 부분을 불러오고 Virtual DOM은 가상의 dom을 만들어 그 안에(<body안에서>) 수정 사항만 불러와 변경한다

### ☝🏻 리액트의 장점 - 2. 컴포넌트 기반 구조
1. 하나의 컴포넌트는 다른 여러개의 컴포턴트 조합으로 구성할 수 있다.
2. 블록을 조립하듯 컴포넌트 조합을 통해 웹사이트 개발이 가능하다 따라서 재사용성이 뛰어나다. ex) AriBnB 사이트

### ☝🏻 리액트의 장점 - 3. 재사용성
1. 반복적인 작업을 줄여주어 <b>생산성</b>을 높여준다.
2. 유지보수의 용이하다
3. 재사용이 가능하려면 해당 모듈의 의존성이 없어야 한다.(독립적으로 사용이 가능한 모듈이어야 한다.)


### ☝🏻 리액트의 장점 - 4. 든든한 지원과 지식공유
1. 메타(페이스북)에서 오픈소스 프로젝트로 관리하여 계속 발전하고 있다
2. 다양한 커뮤니티에서 활발하게 지식이 공유되고 있다 따라서 한글 지식정보도 많다


### ☝🏻 리액트의 장점 - 5. 모바일 앱 개발 가능
1. 리액트 네이티브라는 모바일 환경 UI 프레임웤르르 사용하면 크로스 플랫폼(cross-platform) 모바일 앱을 개발할 수 있다.
---

### ✌🏻 리액트의 단점 - 1.방대한 학습량과 높은 상태 관리 복잡도
1. 자바스크립트를 공부한 경우는 빠르게 학습할 수 있지만 그렇지 않은경우 학습량이 많다.

2. state, component life cycle 등의 개념이 있지만 그렇게 어렵지 않게 상태를 관리할 수 있다.



node.js를 설치하면 nom,npx가 설지가 된다.

---

## 03.09(2주차) 
---
1. git은 프로젝트 버전 관리를 위한 것이다.<br>
2. 코드 수정시 .git이라는 숨김 파일에 저장된다<br>
3. branch라는 곳에 commit과 push로 나의 수정내용을 저장할 수 있다.<br>
4. 나의 로컬 branch -> stage -> 원격(remote) branch 순으로 수정사항이 옮겨가서 저장된다<br>
